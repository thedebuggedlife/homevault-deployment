#!/bin/bash

set -o pipefail

PROJECT_VERSION=0.1
PROJECT_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="${PROJECT_ROOT%/}"

source "$PROJECT_ROOT/lib/logging.sh"
source "$PROJECT_ROOT/lib/config.sh"
source "$PROJECT_ROOT/lib/smtp2go.sh"
source "$PROJECT_ROOT/lib/docker.sh"
source "$PROJECT_ROOT/lib/backup.sh"

declare -g SELECTED_ACTION=
declare -g SHOW_ALL=false
declare -g COMPOSE_PATH=
declare -g PROJECT_PATH=
declare -g SECRETS_PATH=
declare -g OVERRIDE_COMPOSE=true
declare -g OVERRIDE_VERSIONS=false
declare -g UNATTENDED=
declare -g NO_DOWNLOAD=
declare -g USE_SMTP2GO
declare -g USE_DEFAULTS=true
declare -g ENV_FILE=.env
declare -g AS_USER="$USER"
declare -g COMPOSE_PROJECT_NAME=homevault
declare -g COMPOSE_OPTIONS=
declare -g COMPOSE_UP_OPTIONS=
declare -g DRY_RUN=false
declare -g REQUIRES_RESTART=false
declare -gA ENV_OVERRIDES

# Administrator account
declare -g ADMIN_USERNAME=
declare -g ADMIN_PASSWORD=
declare -g ADMIN_EMAIL=
declare -g ADMIN_DISPLAY_NAME=

# Global ENV variables
declare -g APPDATA_LOCATION=
# shellcheck disable=SC2034
declare -g TAILSCALE_IP=
declare -g CF_DOMAIN_NAME=

# Base module should always be first in the list
declare -ga ENABLED_MODULES=("base")
declare -ga INSTALLED_MODULES=()
declare -ga REMOVE_MODULES=()

################################################################################
#                           SETUP MODULES

declare -ga CONFIG_ENV_HOOKS=()
declare -ga CONFIG_SECRETS_HOOKS=()
declare -ga COMPOSE_EXTRA_HOOKS=()
declare -ga PRE_INSTALL_HOOKS=()
declare -ga POST_INSTALL_HOOKS=()
declare -ga BOOTSTRAP_HOOKS=()
declare -ga POST_RESTORE_HOOKS=()
declare -ga BACKUP_CONFIG_HOOKS=()
declare -ga BACKUP_SERVICES=()
declare -ga BACKUP_FILTER_INCLUDE=()
declare -ga BACKUP_FILTER_EXCLUDE=()
declare -gA MODULE_OPTIONS

dedup_modules() {
    local -A seen_modules
    local unique_modules=()

    # First, ensure "base" is always present and in first position
    unique_modules+=("base")
    seen_modules["base"]=1

    for module in "${ENABLED_MODULES[@]}"; do
        if [[ -z "${seen_modules[$module]}" ]]; then
            unique_modules+=("$module")
            seen_modules[$module]=1
        fi
    done

    ENABLED_MODULES=("${unique_modules[@]}")
}

load_modules() {
    log_header "Loading enabled modules"
    dedup_modules
    for module in "${ENABLED_MODULES[@]}"; do
        echo -e "Loading module ${Purple}$module${COff}"
        local module_setup="$PROJECT_ROOT/modules/$module/setup.sh"
        if [ -f "$module_setup" ]; then
            # shellcheck source=/dev/null
            source "$module_setup"
        else
            log_error "Module '$module' is invalid. Use --help flag to see a list of supported modules"
            exit 1
        fi
    done
}

###
# Function to execute all hooks in a given array
#
# Example: 
#   execute_hooks POST_INSTALL_HOOKS[@] "post-install"
#
# @param $hook_array    The hooks to execute
# @param $hook_name     The name of the hook (for logging)
# @return void
###
execute_hooks() {
    local hook_name="${!#}"  # Get the last argument (hook name)
    local -a hooks=("${@:1:$#-1}")  # Get all arguments except the last one
    
    echo -e "\nExecuting ${Purple}$hook_name${COff} hooks...\n" >&2
    for hook in "${hooks[@]}"; do
        if ! $hook; then
            log_error "Hook '$hook' failed"
            exit 1
        fi
    done
}

implicit_env_vars() {
    SECRETS_PATH="${APPDATA_LOCATION%/}/secrets/"
    PROJECT_PATH="${APPDATA_LOCATION%/}/project/$COMPOSE_PROJECT_NAME"
    COMPOSE_PATH="${APPDATA_LOCATION%/}/project/$COMPOSE_PROJECT_NAME/compose"
}

###
# Combine environment files from enabled modules
#
# @return void
###
prepare_env_file() {
    log_header "Preparing environment files"

    local env_exists
    env_exists=$([ -f "$ENV_FILE" ] && echo true || echo false)
    if [ "$env_exists" != "true" ]; then
        echo -e "Creating environment file ${Cyan}$ENV_FILE${COff}"
        touch "$ENV_FILE" && chmod 600 "$ENV_FILE" || {
            log_error "Failed to create environment file: '$ENV_FILE'"
            exit 1
        }
    fi
    for module in "${ENABLED_MODULES[@]}"; do
        local module_env="$PROJECT_ROOT/modules/$module/.env"
        if [ -s "$module_env" ]; then
            while IFS= read -r line || [ -n "$line" ]; do
                # Skip comments and empty lines
                if [[ ! "$line" =~ ^[[:space:]]*# && -n "$line" ]]; then
                    # Extract key from line, everything before first =
                    key="${line%%=*}"
                    if [[ -n "$key" && "$line" == *"="* ]]; then
                        # If key does not already exist in root .env file, append the line
                        if [[ ! -f "$ENV_FILE" ]] || ! grep -q "^${key}=" "$ENV_FILE"; then
                            append_file "$line" "$ENV_FILE"
                            if [ "$env_exists" = "true" ]; then
                                # Only log line by line if .env file already existed
                                echo -e "Updated ${Purple}$key${COff} in ${Cyan}$ENV_FILE${COff}."
                            fi
                        fi
                    fi
                fi
            done < "$module_env"
        fi
    done
    # shellcheck source=/dev/null
    source "$ENV_FILE"
    implicit_env_vars
}

###
# Download application data for all enabled modules
#
# @return void
###
download_appdata() {
    if [ "$NO_DOWNLOAD" = true ]; then return 0; fi
    log_header "Downloading application data for modules"
    for module in "${ENABLED_MODULES[@]}"; do
        download_module_appdata "$module"
    done
}

load_module_help() {
    for module_file in "$PROJECT_ROOT"/modules/*/help.txt; do
        module_name=$(basename "$(dirname "$module_file")")
        #shellcheck disable=SC2034
        MODULE_OPTIONS["$module_name"]=$(cat "$module_file")
    done
}

find_all_modules() {
    for module_file in "$PROJECT_ROOT"/modules/*/setup.sh; do
        module_name=$(basename "$(dirname "$module_file")")
        if [ "$module_name" != "base" ]; then
            ENABLED_MODULES+=("$module_name")
        fi
    done
}

find_installed_modules() {
    # Do not run twice, if install modules have already been detected
    if [[ ${#INSTALLED_MODULES[@]} -gt 0 ]]; then return 0; fi

    log_header "Looking for installed modules"

    if [ "$_DOCKER_INSTALLED" != "true" ]; then return 0; fi

    local container_ids container_id container_labels module_name
    container_ids=$(docker ps -aq --filter "label=com.docker.compose.project=$COMPOSE_PROJECT_NAME")

    for container_id in $container_ids; do
        container_labels=$(docker inspect --format '{{range $k,$v := .Config.Labels}}{{$k}}={{$v}}{{printf "\n"}}{{end}}' "$container_id")
        
        # Find labels matching the pattern selfhost.module.XX=1
        while IFS= read -r label; do
            if [[ "$label" =~ ^selfhost\.module\.(.+)=1$ ]]; then
                module_name="${BASH_REMATCH[1]}"
                INSTALLED_MODULES+=("$module_name")
            fi
        done <<< "$container_labels"
    done

    if [[ ${#INSTALLED_MODULES[@]} -eq 0 ]]; then
        echo "There are no modules installed."
        return 0
    fi

    # Remove duplicates from the array
    mapfile -t INSTALLED_MODULES < <(printf "%s\n" "${INSTALLED_MODULES[@]}" | sort -u)

    local module
    for module in "${INSTALLED_MODULES[@]}"; do
        echo -e "Found installed module: ${Purple}$module${COff}"
        # Enable all installed modules except those marked for removal
        array_contains "$module" "${REMOVE_MODULES[@]}" || ENABLED_MODULES+=("$module")
    done

    dedup_modules
}

find_missing_modules() {
    # Find modules that are installed but not enabled
    local -a missing_modules=()
    local module
    for module in "${INSTALLED_MODULES[@]}"; do
        # shellcheck disable=SC2076
        if [[ ! " ${ENABLED_MODULES[*]} " =~ " ${module} " ]]; then
            missing_modules+=("$module")
        fi
    done

    if [ ${#missing_modules[@]} -gt 0 ]; then
        log_warn "Some modules will be removed by this operation. Please read the following carefully."
        echo "The following modules are installed but were not included in this run:"
        printf "  - %s\n" "${missing_modules[@]}"
        echo -e "\nIf this was unintentional, exit and re-run the script, including them with the -m option."
        echo
        local user_input
        read -p "Do you want to proceed? [y/N] " user_input </dev/tty
        user_input=${user_input:-N}
        if [[ ! "$user_input" =~ ^[Yy]$ ]]; then
            abort_install
        fi
    fi
}

################################################################################
#                            CONFIGURATION STEPS

###
# Create the application data folder (which is mounted into Docker)
#
# @return void
###
create_data_locations() {
    log_header "Preparing application data folder"

    ensure_path_exists "$APPDATA_LOCATION"
    ensure_path_exists "$SECRETS_PATH"
    ensure_path_exists "$PROJECT_PATH"
    ensure_path_exists "$COMPOSE_PATH"
}

###
# Ask for any variables that aren't yet defined in the .env file
#
# @return void
###
ask_for_variables() {
    execute_hooks "${CONFIG_ENV_HOOKS[@]}" "config-env"
    implicit_env_vars
}

###
# Create any missing secret files
#
# @return void
###
save_secrets() {
    log_header "Preparing secret files"
    execute_hooks "${CONFIG_SECRETS_HOOKS[@]}" "config-secrets"
    if ! chmod 644 "${SECRETS_PATH}"*; then
        exit 1
    fi
}

###
# Deploy services via docker compose
#
# @return void
###
deploy_project() {
    COMPOSE_OPTIONS="-p '$COMPOSE_PROJECT_NAME' --env-file '$ENV_FILE' $COMPOSE_OPTIONS"
    COMPOSE_UP_OPTIONS="-d -y --remove-orphans --quiet-pull --wait $COMPOSE_UP_OPTIONS"
    if [ "$DRY_RUN" = true ]; then COMPOSE_UP_OPTIONS+=" --dry-run"; fi


    ensure_path_exists "${COMPOSE_PATH%/}/"
    if [ "$OVERRIDE_COMPOSE" = true ]; then
        rm -rf "${COMPOSE_PATH:?}/"* || {
            log_error "Failed to delete previous compose files"
            exit 1
        }
    fi

    # Grab the default "docker-compose.yml" file for each module
    local -a original_files=()
    local -a project_files=()
    for module in "${ENABLED_MODULES[@]}"; do
        local default_file="${PROJECT_ROOT%/}/modules/$module/docker-compose.yml"
        if [ -f "$default_file" ]; then
            original_files+=("$module:$default_file")
        fi
    done

    # Collect any additional files provided by the enabled modules
    readarray -t extra_files < <(execute_hooks  "${COMPOSE_EXTRA_HOOKS[@]}" "compose-extra")
    original_files+=("${extra_files[@]}")

    # Copy the files to match the following file layout: 
    # "{APPDATA_LOCATION}/project/{PROJECT}/compose/{module}/docker-compose[.{extra}].yml"
    for original_file in "${original_files[@]}"; do
        local project_file target_project inner
        # Original file format "<source_module>:<full_path>[:<target_module>]"
        IFS=':' read -r module original_file inner <<< "$original_file"
        if [ -z "$inner" ]; then
            target_project="$module"
            project_file="${COMPOSE_PATH%/}/$module/$(basename "$original_file")"
        else
            printf '%s\n' "${ENABLED_MODULES[@]}" | grep -q "^$inner$" || continue
            target_project="$inner ($module)"
            project_file="${COMPOSE_PATH%/}/$inner/docker-compose.$module.yml"
        fi
        if [ -f "$original_file" ]; then
            # Copy docker-compose files only if they do not currently exist under appdata (unless overridden)
            # This is important because, the files in appdata may be modified during container-update operations
            if [[ -f "$project_file" ]]; then
                echo -e "Using existing compose file: ${Cyan}$project_file${COff}"
            else
                echo -e "Copying docker compose file for ${Purple}$target_project${COff} to ${Cyan}$project_file${COff}"
                ensure_path_exists "$( dirname "$project_file" )"
                (cp -f "$original_file" "$project_file") || {
                    log_error "Failed to copy docker compose file for '$target_project'"
                    exit 1
                }
            fi
        fi
        if [ -f "$project_file" ]; then
            project_files+=("$project_file")
            COMPOSE_OPTIONS="$COMPOSE_OPTIONS -f '$project_file'"
        fi
    done

    echo

    if [ "$OVERRIDE_VERSIONS" != true ]; then
        if ! compose_match_container_versions "$COMPOSE_PROJECT_NAME" "${project_files[@]}"; then
            log_error "Failed to match existing container versions in compose project files"
            exit 1
        fi
    fi

    local user_input=Y
    if [ "$UNATTENDED" != true ]; then
        echo -en "\n\nProject ${Purple}$COMPOSE_PROJECT_NAME${COff} is ready for docker deployment. "
        read -p "Do you want to proceed? [Y/n] " user_input </dev/tty
        user_input=${user_input:-Y}
    fi
    if [[ ! "$user_input" =~ ^[Yy]$ ]]; then
        abort_install
    fi

    execute_hooks "${PRE_INSTALL_HOOKS[@]}" "pre-install"

    log_header "Deploying services"

    echo -e "Deploying project ${Purple}$COMPOSE_PROJECT_NAME${COff}..."
    if ! sg docker -c "docker compose $COMPOSE_OPTIONS up $COMPOSE_UP_OPTIONS"; then
        log_error "Docker Compose deployment failed"
        exit 1
    fi

    log_header "Finalizing deployment"

    execute_hooks "${POST_INSTALL_HOOKS[@]}" "post-install"

    execute_hooks "${BOOTSTRAP_HOOKS[@]}" "bootstrap"

    save_deployment_file || exit 1
}

###
# Create the variables with values for server administrator account and save
# them to the file used for LLDAP bootstrap
#
# Options:
#   -l      Load only, do not save to file (for post-install steps only)
#
# @return void
###
configure_admin_account() {
    log_header "Configuring administrator account"

    local config_file="${APPDATA_LOCATION%/}/lldap/bootstrap/user-configs/admin.json"
    local load_only=false
    OPTIND=1
    while getopts ":l" opt; do
        case $opt in
            l) load_only=true ;;
            \?) log_warn "Invalid option: -$OPTARG" ;;
        esac
    done

    # Apply any overrides passed via -o flag
    ADMIN_USERNAME="${ENV_OVERRIDES[ADMIN_USERNAME]}"
    ADMIN_EMAIL="${ENV_OVERRIDES[ADMIN_EMAIL]}"
    ADMIN_PASSWORD="${ENV_OVERRIDES[ADMIN_PASSWORD]}"
    ADMIN_DISPLAY_NAME="${ENV_OVERRIDES[ADMIN_DISPLAY_NAME]}"

    local save_file=false
    if [[ -n "$ADMIN_USERNAME" || -n "$ADMIN_EMAIL" || -n "$ADMIN_PASSWORD" || -n "$ADMIN_DISPLAY_NAME" ]]; then
        save_file=true
    fi

    # Read missing values from file (if it exists)
    if [[ -f "$config_file" ]]; then
        ADMIN_USERNAME=${ADMIN_USERNAME:-"$(jq -r '.id' "$config_file")"}
        ADMIN_EMAIL=${ADMIN_EMAIL:-"$(jq -r '.email' "$config_file")"}
        ADMIN_PASSWORD=${ADMIN_PASSWORD:-"$(jq -r '.password' "$config_file")"}
        ADMIN_DISPLAY_NAME=${ADMIN_DISPLAY_NAME:-"$(jq -r '.displayName' "$config_file")"}
    fi

    # If already configured and the --resume flag was specified, skip the rest
    if [[ -z "$ADMIN_USERNAME" || -z "$ADMIN_EMAIL" || -z "$ADMIN_PASSWORD" || -z "$ADMIN_DISPLAY_NAME" || "$USE_DEFAULTS" != "true" ]]; then

        echo -e "The following user will be created and configured with ${Yellow}administrator privileges${COff} across all applications."
        echo

        ADMIN_USERNAME=$(ask_value "Username" -d "$ADMIN_USERNAME")
        ADMIN_EMAIL=$(ask_value "Email address" -d "$ADMIN_EMAIL")
        while true; do
            local confirm_pass
            ADMIN_PASSWORD=$(ask_value "Password" -m)
            confirm_pass=$(ask_value "Confirm password" -m)
            if [ "$ADMIN_PASSWORD" != "$confirm_pass" ]; then
                log_warn "Passwords do not match. Please try again."
            else
                break
            fi
        done
        ADMIN_DISPLAY_NAME=$(ask_value "Display name (e.g. <First> <Last>)" -d "$ADMIN_DISPLAY_NAME")
        save_file=true
    fi

    if [ "$load_only" = "true" ]; then 
        save_env ADMIN_EMAIL "$ADMIN_EMAIL"
        return 0
    fi

    if [ "$save_file" = "true" ]; then
        local json
        if ! json=$( [ -s "$config_file" ] && cat "$config_file" || echo "{}" ); then
            log_error "Failed to read JSON for server administrator"
            exit 1
        fi
        if ! json=$(echo "$json" | jq \
            --arg id "$ADMIN_USERNAME" \
            --arg email "$ADMIN_EMAIL" \
            --arg password "$ADMIN_PASSWORD" \
            --arg displayName "$ADMIN_DISPLAY_NAME" '
            .id = $id |
            .email = $email |
            .password = $password |
            .displayName = $displayName
        '); then
            log_error "Failed to update JSON for server administrator"
            exit 1
        fi
        write_file "$json" "$config_file"
    fi

    save_env ADMIN_EMAIL "$ADMIN_EMAIL"
    write_file "$ADMIN_USERNAME" "${SECRETS_PATH}server_admin_username"
    write_file "$ADMIN_PASSWORD" "${SECRETS_PATH}server_admin_password"
}

check_reboot_needed() {
    if [ "$REQUIRES_RESTART" = true ]; then
        log_warn "The system must be rebooted to complete the requested operation."
        if [ "$UNATTENDED" = true ]; then
            echo -e "\nThe system will reboot in 15 seconds..."
            sleep 15
            sudo shutdown -r now
            exit
        else
            echo ""
            read -p "Do you want to reboot now? [Y/n] " user_input </dev/tty
            user_input=${user_input:-Y}
            if [[ "$user_input" =~ ^[Yy]$ ]]; then
                sudo shutdown -r now
                exit
            fi
        fi
    fi
}

# Terminate program
abort_install() {
    log_warn "Setup aborted by user."
    exit 1
}

print_usage() {
    echo -e "\nUsage: $0 [global options] <action> [action options]"

    if [ -z "$SELECTED_ACTION" ]; then
        echo -e "\nActions:\n"
        echo "  deploy      Installs and/or updates modules in the project."
        echo "  backup      Creates a new recovery snapshot with the current statue of the project."
        echo "  snapshots   List and/or manage existing recovery snapshots."
        echo "  restore     Recovers the state of the project from a previous snapshot."
        echo "  modules     Shows information about installed or available modules."
        echo -e "\nTo display help for an action:\n"
        echo "  $0 <action> --help"

    elif [ "$SELECTED_ACTION" = "deploy" ]; then
        echo -e "\nDeploy options:\n"
        echo "  -m, --module <module>           Includes the given module in the project. Can be specified multiple times."
        echo "      --module all                Enables all available modules."
        echo -e "  --rm <module>                   Removes a module that had been previously installed. ${IRed}Use with caution!${COff}" 
        echo "  -o, --override <var>=<value>    Override environment variable. Can be specified multiple times."
        echo "  --no-download                   Do not download appdata from GitHub. Only use if appdata was previously downloaded."
        echo -e "  --keep-compose                  Do not override previously deployed docker-compose files. ${IRed}Use with caution!${COff}"
        echo -e "  --override-versions             Override running versions with those specified in compose files. ${IRed}Use with caution!${COff}"
        echo "  --dry-run                       Execute docker compose in dry run mode."

    elif [ "$SELECTED_ACTION" = "backup" ]; then
        echo -e "\nBackup options:\n"
        echo "  --init [env_file]               Initialize the backup configuration. Must be run once before creating a snapshot."
        echo "                                    If [env_file] is provided, it is used to initialize restic environment variables."
        echo "  --restic-var <var>=<value>      Specify a restic variable value. Can be specified multiple times."
        echo "  --keep                          Exclude the new snapshot from the automatic retention policy."
        echo "  --dry-run                       Execute restic in dry run mode."

    elif [ "$SELECTED_ACTION" = "snapshots" ]; then
        echo -e "\nSnapshot options:\n"
        echo "  --browse <id> [dir]             Show contents of a snapshot by ID. You may specify: 'latest'."
        echo "                                    If [dir] is specified, only files under the specified directory are listed."
        echo "  --recursive                     Include all files and folders recursively. Valid only when --browse is used."
        echo "  --forget <id>                   Delete the snapshot referenced by ID. You may specify: 'latest'."
        echo "  --retention [policy]            Configure the retention policy for automatic snapshots."
        echo "                                    Format: [#h][#d][#w][#m][#y] Where: h=hour,d=day,w=week,m=month,y=hear"
        echo "                                    Default: 30d12m10y"
        echo "                                    Examples:"
        echo "                                      --retention 24h7d (keep last 24 hourly and last 7 daily snapshots)"
        echo "                                      --retention 4w6m  (keep last 4 weekly and last 6 monthly snapshots)"
        echo "  --dry-run                       Execute restic in dry run mode."

    elif [ "$SELECTED_ACTION" = "restore" ]; then
        echo -e "\nRestore options:\n"
        echo "  --local [appdata path]          Restore from a local appdata (default behavior). Cannot be used with --snapshot"
        echo "                                    If a path is not specified, it defaults to the configuration in project .env file."
        echo "  --snapshot [id]                 Restore from a remote snapshot. Cannot be used with --local"
        echo "                                    If a snapshot ID is not specified, it defaults to the latest snapshot taken."
        echo "  --restic-env <env_file>         Use the values in the specified .env file to locate the restic repository."
        echo "  --restic-var <var>=<value>      Specify a restic variable value. Can be specified multiple times."
        echo "  --dry-run                       Execute restic and docker compose in dry run mode."

    elif [ "$SELECTED_ACTION" = "modules" ]; then
        echo -e "\Modules options:\n"
        echo "  --all                           Show information for all modules available. Otherwise only installed modules are shown."
    fi

    echo -e "\nGlobal options:\n"
    echo "  -h, --help                      Display this help message."
    echo "  -u, --user <user>               User to apply for file permissions. [Default: '$USER']"
    echo "  --always-ask                    Force interactive prompts for settings with a default or previously provided."
    echo "  --unattended                    Do not stop for any prompt. Safe prompts will be auto-accepted."
    echo "                                    Prompts that cannot be auto-accepted will cause the script to exit with a failure code."

    exit 1
}

show_modules() {
    if [ "$SHOW_ALL" = true ]; then
        load_module_help
        echo -e "\nAvailable modules:\n"
        log_options MODULE_OPTIONS true
    else
        find_installed_modules
        echo
    fi

    exit 0
}

check_action_for_option() {
    local option=$2
    local valid_actions
    IFS=':' read -ra valid_actions <<< "$1"
    if [ -z "$SELECTED_ACTION" ]; then
        log_invalid "$option is not a global option"
        print_usage
    elif ! array_contains "$SELECTED_ACTION" "${valid_actions[@]}"; then
        log_invalid "$option is not supported for action: $SELECTED_ACTION"
        print_usage
    fi
}

parse_env_override() {
    local -n overrides=$3
    if [ -n "$2" ]; then
        # Parse override in form of: VARIABLE_NAME=VALUE
        if echo "$2" | grep -q '='; then
            # shellcheck disable=SC2034
            overrides["$(echo "$2" | cut -d '=' -f 1)"]="$(echo "$2" | cut -d '=' -f 2-)"
        else
            log_invalid "$1 requires an assignment in the form VARIABLE_NAME=VALUE."
            return 1
        fi
    else
        log_invalid "$1 requires an assignment in the form VARIABLE_NAME=VALUE."
        return 1
    fi
}

parse_command_line() {
    while [ "$#" -gt 0 ]; do
        case "$(echo "$1" | tr '[:upper:]' '[:lower:]')" in
        ## ACTIONS
        deploy)
            if [ -n "$SELECTED_ACTION" ]; then log_invalid "Only 1 action can be selected at a time"; exit 1; fi
            SELECTED_ACTION="deploy"
            shift 1
            ;;
        backup)
            if [ -n "$SELECTED_ACTION" ]; then log_invalid "Only 1 action can be selected at a time"; exit 1; fi
            SELECTED_ACTION="backup"
            shift 1
            ;;
        snapshots)
            if [ -n "$SELECTED_ACTION" ]; then log_invalid "Only 1 action can be selected at a time"; exit 1; fi
            SELECTED_ACTION="snapshots"
            shift 1
            ;;
        restore)
            if [ -n "$SELECTED_ACTION" ]; then log_invalid "Only 1 action can be selected at a time"; exit 1; fi
            SELECTED_ACTION="restore"
            shift 1
            ;;
        modules)
            if [ -n "$SELECTED_ACTION" ]; then log_invalid "Only 1 action can be selected at a time"; exit 1; fi
            SELECTED_ACTION="modules"
            shift 1
            ;;
        ## GLOBAL OPTIONS
        --user | -u)
            if [ -n "$2" ]; then
                AS_USER="$2"
                shift 2
            else
                log_invalid "$1 requires a value."
                exit 1
            fi
            ;;
        --unattended)
            UNATTENDED=true
            USE_DEFAULTS=true
            shift 1
            ;;
        --always-ask)
            USE_DEFAULTS=false
            shift 1
            ;;
        -h | --help)
            print_usage
            ;;
        ## DEPLOY OPTIONS
        --module | -m)
            check_action_for_option deploy "$1"
            if [ -n "$2" ]; then
                if [ "$2" = "all" ]; then 
                    find_all_modules
                else
                    ENABLED_MODULES+=("$2")
                fi
                dedup_modules
                shift 2
            else
                log_invalid "$1 requires a value."
                exit 1
            fi
            ;;
        --rm)
            check_action_for_option deploy "$1"
            if [ -n "$2" ]; then
                REMOVE_MODULES+=("$2")
                shift 2
            else
                log_invalid "$1 requires a value."
                exit 1
            fi
            ;;
        --keep-compose)
            check_action_for_option deploy "$1"
            OVERRIDE_COMPOSE=false
            shift 1
            ;;
        --override | -o)
            check_action_for_option deploy "$1"
            parse_env_override "$1" "$2" ENV_OVERRIDES || exit 1
            shift 2
            ;;
        --override-versions)
            check_action_for_option deploy "$1"
            OVERRIDE_VERSIONS=true
            shift 1
            ;;
        --no-download)
            check_action_for_option deploy "$1"
            NO_DOWNLOAD=true
            shift 1
            ;;
        ## BACKUP OPTIONS
        --init)
            check_action_for_option backup "$1"
            BACKUP_ACTION=init
            shift 1
            if [[ -n "$1" && "$1" != -* ]]; then
                if [ ! -f "$1" ]; then
                    log_error "--init: File not found: '$1'"
                    exit 1
                fi
                RESTIC_INIT_ENV="$1"
                shift 1
            fi
            ;;
        --keep)
            check_action_for_option backup "$1"
            if [ "$BACKUP_ACTION" != "run" ]; then
                log_error "$1 cannot be used in combination with --$BACKUP_ACTION"
                exit 1
            fi
            BACKUP_KEEP=true
            shift 1
            ;;
        ## SNAPSHOT OPTIONS
        --browse)
            check_action_for_option snapshots "$1"
            if [ "$SNAPSHOT_ACTION" != "list" ]; then
                log_error "$1 cannot be used in combination with --$SNAPSHOT_ACTION"
                exit 1
            fi
            if [ -n "$2" ]; then
                SNAPSHOT_ACTION=browse
                SNAPSHOT_ID="$2"
                shift 2
                if [[ -n "$1" && "$1" != -* ]]; then
                    SNAPSHOT_BROWSE_FLAGS+=("$1")
                    shift 1
                fi
            else
                log_invalid "$1 requires a value for snapshot ID."
                exit 1
            fi
            ;;
        --recursive)
            check_action_for_option snapshots "$1"
            if [ "$SNAPSHOT_ACTION" != "browse" ]; then
                log_error "$1 is only valid when used with --browse"
                exit 1
            fi
            SNAPSHOT_BROWSE_FLAGS+=("--recursive")
            shift
            ;;
        --forget)
            check_action_for_option snapshots "$1"
            if [ "$SNAPSHOT_ACTION" != "list" ]; then
                log_error "$1 cannot be used in combination with --$SNAPSHOT_ACTION"
                exit 1
            fi
            if [ -n "$2" ]; then
                SNAPSHOT_ACTION=forget
                SNAPSHOT_ID="$2"
                shift 2
            else
                log_invalid "$1 requires a value."
                exit 1
            fi
            ;;
        --retention)
            check_action_for_option snapshots "$1"
            if [ "$SNAPSHOT_ACTION" != "list" ]; then
                log_error "$1 cannot be used in combination with --$SNAPSHOT_ACTION"
                exit 1
            fi
            if [ -n "$2" ]; then
                SNAPSHOT_ACTION=retention
                SNAPSHOT_RETENTION="$2"
                shift 2
            else
                log_invalid "$1 requires a value."
                exit 1
            fi
            ;;
        ## RESTORE OPTIONS
        --local)
            check_action_for_option restore "$1"
            if [ -n "$RESTORE_ACTION" ]; then
                log_error "$1 cannot be used in combination with --$RESTORE_ACTION"
                exit 1
            fi
            RESTORE_ACTION=local
            shift 1
            if [[ "$1" != -* ]]; then
                APPDATA_LOCATION="$1"
                shift 1
            fi
            ;;
        --snapshot)
            check_action_for_option restore "$1"
            if [ -n "$RESTORE_ACTION" ]; then
                log_error "$1 cannot be used in combination with --$RESTORE_ACTION"
                exit 1
            fi
            RESTORE_ACTION=snapshot
            shift 1
            if [[ -n "$1" && "$1" != -* ]]; then
                SNAPSHOT_ID="$1"
                shift 1
            fi
            ;;
        --restic-env)
            check_action_for_option restore "$1"
            if [ -n "$RESTIC_ENV" ]; then
                log_error "$1 can only be specified once"
                exit 1
            fi
            if [ -n "$2" ]; then
                if [ ! -f "$2" ]; then
                    log_error "$1: File '$2' does not exist"
                    exit 1
                fi
                RESTIC_ENV="$2"
                shift 2
            else
                log_invalid "$1 requires a value."
                exit 1
            fi
            ;;
        ## MODULE OPTIONS
        --all)
            check_action_for_option modules "$1"
            SHOW_ALL=true
            shift 1
            ;;
        ## SHARED OPTIONS
        --restic-var)
            check_action_for_option backup:restore "$1"
            parse_env_override "$1" "$2" RESTIC_OVERRIDES || exit 1
            shift 2
            ;;
        --dry-run)
            check_action_for_option deploy:backup:snapshots:restore "$1"
            DRY_RUN=true
            shift 1
            ;;
        *)
            log_invalid "Unknown option: $1"
            print_usage
            ;;
        esac
    done

    if [ -z "$SELECTED_ACTION" ]; then
        log_invalid "Missing action parameter"
        print_usage
    fi
}

run_deploy() {
    find_installed_modules
    load_modules
    configure_docker
    prepare_env_file
    ask_for_variables
    create_data_locations
    download_appdata
    configure_admin_account
    configure_tailscale || exit 1
    configure_cloudflare_tunnel
    configure_smtp2go
    save_secrets
    find_missing_modules
    deploy_project
}

backup_action_init() {
    log_header "Initializing backup repository"
    backup_check_requisites || exit 1
    restic_init_env || exit 1
    load_deployment_file || exit 1
    restic_init_repository || exit 1
}

backup_action_run() {
    local exit_code
    log_header "Creating a new recovery snapshot"
    backup_check_requisites || exit 1
    load_deployment_file || exit 1
    backup_stop_services || exit 1
    restic_run_backup; exit_code=$?
    backup_start_services
    if [ $exit_code -ne 0 ]; then return $exit_code; fi
}

run_backup() {
    configure_docker
    find_installed_modules
    prepare_env_file
    backup_action_"${BACKUP_ACTION}"
}

snapshots_action_list() {
    log_header "Enumerating existing recovery snapshots"
    restic_list_snapshots || exit 1
}

snapshots_action_browse() {
    log_header "Browsing snapshot contents"
    restic_browse_snapshot || exit 1
}

snapshots_action_forget() {
    log_header "Removing an existing recovery snapshot"
    restic_forget_snapshots || exit 1
    restic_list_snapshots || exit 1
}

run_snapshots() {
    configure_docker
    prepare_env_file
    snapshots_action_"${SNAPSHOT_ACTION}"
}

restore_action_local() {
    log_header "Performing local restore operation"
    restore_configure_local || exit 1
    load_deployment_file || exit 1
    run_deploy
}

restore_action_snapshot() {
    log_header "Performing remote restore operation"
    restore_configure_remote || exit 1
    restore_snapshot || exit 1
    restore_configure_local || exit 1
    run_deploy
}

run_restore() {
    configure_docker
    find_installed_modules
    restore_check_installed || abort_install
    restore_action_"${RESTORE_ACTION}"
    execute_hooks "${POST_RESTORE_HOOKS[@]}" "post-restore"
}

run_modules() {
    show_modules
}

################################################################################
#                           MAIN PROGRAM LOGIC

trap "echo && abort_install" SIGINT

parse_command_line "$@"

run_${SELECTED_ACTION}

log_done

check_reboot_needed